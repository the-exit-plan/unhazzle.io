'use client';

import React, { createContext, useContext, useState, ReactNode } from 'react';

// Types for our deployment configuration
export interface UserInfo {
  name: string;
  githubUsername?: string;
}

export interface QuestionnaireAnswers {
  appType: 'ecommerce' | 'saas' | 'api' | 'content';
  traffic: 'steady' | 'burst' | 'global' | 'regional';
  database: 'postgres' | 'mysql' | 'mongodb' | 'none';
  cache: 'redis' | 'memcached' | 'none';
}

// Project and Environment structure for hierarchical navigation
export interface Environment {
  id: string;
  name: string; // 'dev', 'staging', 'prod', etc.
  containers: ContainerConfig[];
  database?: {
    engine: string;
    version: string;
    cpu: string;
    memory: string;
    storage: string;
    backups: { enabled: boolean; retention: string; frequency: string };
    replicas: string;
  };
  cache?: {
    engine: string;
    version: string;
    memory: string;
    evictionPolicy: string;
    persistence: string;
  };
}

export interface Project {
  id: string;
  name: string;
  environments: Environment[];
}

export interface VolumeConfig {
  mountPath: string;
  sizeGB: number;
  autoScale: boolean;
  backupFrequency: 'disabled' | 'hourly' | 'daily' | 'weekly';
  deleteWithContainer: boolean;
}

export interface ContainerConfig {
  id: string;
  name: string;
  imageUrl: string;
  registryUsername?: string;
  registryToken?: string;
  port: number;
  healthCheck: {
    protocol: 'HTTP' | 'TCP' | 'gRPC';
    port: number;
    path?: string;
    interval: string;
    timeout: string;
    retries: number;
  };
  exposure: 'public' | 'private';
  customDomain?: string;
  resources: {
    cpu: string;
    memory: string;
    replicas: { min: number; max: number };
  };
  volume?: VolumeConfig;
  serviceAccess: {
    database: boolean;
    cache: boolean;
  };
  environmentVariables: {
    key: string;
    value: string;
    masked?: boolean;
  }[];
}

// Legacy single container support (deprecated but maintained for backward compatibility)
export interface ApplicationConfig {
  imageUrl: string;
  registryUsername?: string;
  registryToken?: string;
  port?: number;
  healthCheck?: string;
}

export interface ResourceConfig {
  replicas: { min: number; max: number };
  cpu: string;
  memory: string;
  database?: {
    engine: string;
    version: string;
    cpu: string;
    memory: string;
    storage: string;
    backups: { enabled: boolean; retention: string; frequency: string };
    replicas: string;
  };
  cache?: {
    engine: string;
    version: string;
    memory: string;
    evictionPolicy: string;
    persistence: string;
  };
}

export interface EnvironmentVariables {
  userSecrets: { key: string; value: string; masked?: boolean }[];
  autoGenerated: { key: string; value: string; readOnly: boolean }[];
}

export interface DomainConfig {
  customDomain?: string;
  defaultSubdomain: string;
  dnsInstructions?: string;
}

export interface CostBreakdown {
  application: number;
  database?: number;
  cache?: number;
  loadBalancer: number;
  bandwidth: number;
  total: number;
}

export interface DeploymentState {
  user: UserInfo | null;
  questionnaire: QuestionnaireAnswers | null;
  application: ApplicationConfig | null; // Legacy support
  containers: ContainerConfig[]; // Legacy: will be migrated to project.environments[0].containers
  resources: ResourceConfig | null;
  environment: EnvironmentVariables | null;
  domain: DomainConfig | null;
  cost: CostBreakdown | null;
  deployed: boolean;
  // New: Project-based structure
  project: Project | null;
}

interface DeploymentContextType {
  state: DeploymentState;
  updateUser: (user: UserInfo) => void;
  updateQuestionnaire: (answers: QuestionnaireAnswers) => void;
  updateApplication: (config: ApplicationConfig) => void; // Legacy
  addContainer: (container: ContainerConfig) => void;
  clearContainers: () => void;
  updateContainer: (id: string, container: Partial<ContainerConfig>) => void;
  removeContainer: (id: string) => void;
  updateResources: (config: ResourceConfig) => void;
  updateEnvironment: (env: EnvironmentVariables) => void;
  updateDomain: (domain: DomainConfig) => void;
  updateCost: (cost: CostBreakdown) => void;
  markDeployed: () => void;
  resetState: () => void;
  removeDatabase: () => void;
  removeCache: () => void;
}

const DeploymentContext = createContext<DeploymentContextType | undefined>(undefined);

const initialState: DeploymentState = {
  user: null,
  questionnaire: null,
  application: null,
  containers: [],
  resources: null,
  environment: null,
  domain: null,
  cost: null,
  deployed: false,
  project: null,
};

export function DeploymentProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<DeploymentState>(() => {
    // Initialize from localStorage if available
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('unhazzle-deployment-state');
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          // Ensure containers array exists for backward compatibility
          const containers = parsed.containers || [];
          
          // If deployed but no project structure, create it from legacy data
          let project = parsed.project;
          if (parsed.deployed && !project && containers.length > 0) {
            project = {
              id: 'proj-' + Date.now(),
              name: parsed.questionnaire?.appType ? `${parsed.questionnaire.appType} Application` : 'My Application',
              environments: [
                {
                  id: 'env-dev-' + Date.now(),
                  name: 'dev',
                  containers: containers,
                  database: parsed.resources?.database,
                  cache: parsed.resources?.cache,
                }
              ]
            };
          }
          
          return {
            ...parsed,
            containers,
            project
          };
        } catch (e) {
          console.error('Failed to parse saved state:', e);
        }
      }
    }
    return initialState;
  });

  const updateUser = (user: UserInfo) => {
    setState(prev => {
      const newState = { ...prev, user };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateQuestionnaire = (answers: QuestionnaireAnswers) => {
    setState(prev => {
      const newState = { ...prev, questionnaire: answers };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateApplication = (config: ApplicationConfig) => {
    setState(prev => {
      const newState = { ...prev, application: config };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const addContainer = (container: ContainerConfig) => {
    setState(prev => {
      const existingContainers = prev.containers || [];
      const newState = { ...prev, containers: [...existingContainers, container] };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const clearContainers = () => {
    setState(prev => {
      const newState = { ...prev, containers: [] };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateContainer = (id: string, updates: Partial<ContainerConfig>) => {
    setState(prev => {
      const existingContainers = prev.containers || [];
      const updatedContainers = existingContainers.map(c => 
        c.id === id ? { ...c, ...updates } : c
      );
      
      // Also update project environment structure
      let updatedProject = prev.project;
      if (prev.project?.environments?.[0]) {
        updatedProject = {
          ...prev.project,
          environments: prev.project.environments.map((env: Environment, idx: number) => {
            if (idx === 0) {
              // Update containers in first environment
              return {
                ...env,
                containers: updatedContainers,
              };
            }
            return env;
          })
        };
      }
      
      const newState = {
        ...prev,
        containers: updatedContainers,
        project: updatedProject
      };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const removeContainer = (id: string) => {
    setState(prev => {
      const existingContainers = prev.containers || [];
      const updatedContainers = existingContainers.filter(c => c.id !== id);
      
      // Also update project environment structure
      let updatedProject = prev.project;
      if (prev.project?.environments?.[0]) {
        updatedProject = {
          ...prev.project,
          environments: prev.project.environments.map((env: Environment, idx: number) => {
            if (idx === 0) {
              // Update containers in first environment
              return {
                ...env,
                containers: updatedContainers,
              };
            }
            return env;
          })
        };
      }
      
      const newState = {
        ...prev,
        containers: updatedContainers,
        project: updatedProject
      };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  // Remove database service from resources and clean up container references
  const removeDatabase = () => {
    setState(prev => {
      // Toggle off DB access and remove related env vars from all containers
      const cleanedContainers = (prev.containers || []).map(c => {
        if (!c.serviceAccess?.database) return c;
        const filteredEnv = (c.environmentVariables || []).filter(v => v.key !== 'UNHAZZLE_POSTGRES_URL' && v.key !== 'DATABASE_URL');
        return {
          ...c,
          serviceAccess: { ...c.serviceAccess, database: false },
          environmentVariables: filteredEnv,
        };
      });

      // Update resources (if present) by removing database
      const newResources = prev.resources ? { ...prev.resources, database: undefined } : prev.resources;

      // Remove auto-generated DATABASE_URL from environment if present
      let newEnv = prev.environment;
      if (prev.environment?.autoGenerated) {
        newEnv = {
          ...prev.environment,
          autoGenerated: prev.environment.autoGenerated.filter((e: any) => e.key !== 'DATABASE_URL')
        } as any;
      }

      // Also update project environment structure
      let updatedProject = prev.project;
      if (prev.project?.environments?.[0]) {
        updatedProject = {
          ...prev.project,
          environments: prev.project.environments.map((env: Environment, idx: number) => {
            if (idx === 0) {
              return {
                ...env,
                containers: cleanedContainers,
                database: undefined,
              };
            }
            return env;
          })
        };
      }

      const newState = { 
        ...prev, 
        containers: cleanedContainers, 
        resources: newResources, 
        environment: newEnv,
        project: updatedProject
      };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  // Remove cache service from resources and clean up container references
  const removeCache = () => {
    setState(prev => {
      // Toggle off cache access and remove related env vars from all containers
      const cleanedContainers = (prev.containers || []).map(c => {
        if (!c.serviceAccess?.cache) return c;
        const filteredEnv = (c.environmentVariables || []).filter(v => v.key !== 'UNHAZZLE_REDIS_URL' && v.key !== 'REDIS_URL');
        return {
          ...c,
          serviceAccess: { ...c.serviceAccess, cache: false },
          environmentVariables: filteredEnv,
        };
      });

      // Update resources (if present) by removing cache
      const newResources = prev.resources ? { ...prev.resources, cache: undefined } : prev.resources;

      // Remove auto-generated REDIS_URL from environment if present
      let newEnv = prev.environment;
      if (prev.environment?.autoGenerated) {
        newEnv = {
          ...prev.environment,
          autoGenerated: prev.environment.autoGenerated.filter((e: any) => e.key !== 'REDIS_URL')
        } as any;
      }

      // Also update project environment structure
      let updatedProject = prev.project;
      if (prev.project?.environments?.[0]) {
        updatedProject = {
          ...prev.project,
          environments: prev.project.environments.map((env: Environment, idx: number) => {
            if (idx === 0) {
              return {
                ...env,
                containers: cleanedContainers,
                cache: undefined,
              };
            }
            return env;
          })
        };
      }

      const newState = { 
        ...prev, 
        containers: cleanedContainers, 
        resources: newResources, 
        environment: newEnv,
        project: updatedProject
      };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateResources = (config: ResourceConfig) => {
    setState(prev => {
      // Update both legacy resources AND project environment structure
      let updatedProject = prev.project;
      
      if (prev.project?.environments?.[0]) {
        // Update the first environment (typically 'dev') with new database/cache config
        updatedProject = {
          ...prev.project,
          environments: prev.project.environments.map((env: Environment, idx: number) => {
            if (idx === 0) {
              // Update first environment
              return {
                ...env,
                database: config.database,
                cache: config.cache,
              };
            }
            return env;
          })
        };
      }
      
      const newState = { ...prev, resources: config, project: updatedProject };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateEnvironment = (env: EnvironmentVariables) => {
    setState(prev => {
      const newState = { ...prev, environment: env };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateDomain = (domain: DomainConfig) => {
    setState(prev => {
      const newState = { ...prev, domain: domain };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateCost = (cost: CostBreakdown) => {
    setState(prev => {
      const newState = { ...prev, cost };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const markDeployed = () => {
    setState(prev => {
      // Create project structure with default 'dev' environment
      const project: Project = {
        id: 'proj-' + Date.now(),
        name: prev.questionnaire?.appType ? `${prev.questionnaire.appType} Application` : 'My Application',
        environments: [
          {
            id: 'env-dev-' + Date.now(),
            name: 'dev',
            containers: prev.containers || [],
            database: prev.resources?.database,
            cache: prev.resources?.cache,
          }
        ]
      };

      const newState = { ...prev, deployed: true, project };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const resetState = () => {
    setState(initialState);
    if (typeof window !== 'undefined') {
      localStorage.removeItem('unhazzle-deployment-state');
    }
  };

  return (
    <DeploymentContext.Provider
      value={{
        state,
        updateUser,
        updateQuestionnaire,
        updateApplication,
        addContainer,
        clearContainers,
        updateContainer,
        removeContainer,
        updateResources,
        updateEnvironment,
        updateDomain,
        updateCost,
        markDeployed,
        resetState,
        removeDatabase,
        removeCache,
      }}
    >
      {children}
    </DeploymentContext.Provider>
  );
}

export function useDeployment() {
  const context = useContext(DeploymentContext);
  if (context === undefined) {
    throw new Error('useDeployment must be used within a DeploymentProvider');
  }
  return context;
}
