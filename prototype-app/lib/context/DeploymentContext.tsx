'use client';

import React, { createContext, useContext, useState, ReactNode } from 'react';

// Types for our deployment configuration
export interface UserInfo {
  name: string;
  githubUsername?: string;
}

export interface QuestionnaireAnswers {
  appType: 'ecommerce' | 'saas' | 'api' | 'content';
  traffic: 'steady' | 'burst' | 'global' | 'regional';
  database: 'postgres' | 'mysql' | 'mongodb' | 'none';
  cache: 'redis' | 'memcached' | 'none';
}

export interface VolumeConfig {
  mountPath: string;
  sizeGB: number;
  autoScale: boolean;
  backupFrequency: 'disabled' | 'hourly' | 'daily' | 'weekly';
  deleteWithContainer: boolean;
}

export interface ContainerConfig {
  id: string;
  name: string;
  imageUrl: string;
  registryUsername?: string;
  registryToken?: string;
  port: number;
  healthCheck: {
    protocol: 'HTTP' | 'TCP' | 'gRPC';
    port: number;
    path?: string;
    interval: string;
    timeout: string;
    retries: number;
  };
  exposure: 'public' | 'private';
  customDomain?: string;
  resources: {
    cpu: string;
    memory: string;
    replicas: { min: number; max: number };
  };
  volume?: VolumeConfig;
  serviceAccess: {
    database: boolean;
    cache: boolean;
  };
  environmentVariables: {
    key: string;
    value: string;
    masked?: boolean;
  }[];
}

// Legacy single container support (deprecated but maintained for backward compatibility)
export interface ApplicationConfig {
  imageUrl: string;
  registryUsername?: string;
  registryToken?: string;
  port?: number;
  healthCheck?: string;
}

export interface ResourceConfig {
  replicas: { min: number; max: number };
  cpu: string;
  memory: string;
  database?: {
    engine: string;
    version: string;
    cpu: string;
    memory: string;
    storage: string;
    backups: { enabled: boolean; retention: string; frequency: string };
    replicas: string;
  };
  cache?: {
    engine: string;
    version: string;
    memory: string;
    evictionPolicy: string;
    persistence: string;
  };
}

export interface EnvironmentVariables {
  userSecrets: { key: string; value: string; masked?: boolean }[];
  autoGenerated: { key: string; value: string; readOnly: boolean }[];
}

export interface DomainConfig {
  customDomain?: string;
  defaultSubdomain: string;
  dnsInstructions?: string;
}

export interface CostBreakdown {
  application: number;
  database?: number;
  cache?: number;
  loadBalancer: number;
  bandwidth: number;
  total: number;
}

export interface DeploymentState {
  user: UserInfo | null;
  questionnaire: QuestionnaireAnswers | null;
  application: ApplicationConfig | null; // Legacy support
  containers: ContainerConfig[]; // New multi-container support
  resources: ResourceConfig | null;
  environment: EnvironmentVariables | null;
  domain: DomainConfig | null;
  cost: CostBreakdown | null;
  deployed: boolean;
}

interface DeploymentContextType {
  state: DeploymentState;
  updateUser: (user: UserInfo) => void;
  updateQuestionnaire: (answers: QuestionnaireAnswers) => void;
  updateApplication: (config: ApplicationConfig) => void; // Legacy
  addContainer: (container: ContainerConfig) => void;
  updateContainer: (id: string, container: Partial<ContainerConfig>) => void;
  removeContainer: (id: string) => void;
  updateResources: (config: ResourceConfig) => void;
  updateEnvironment: (env: EnvironmentVariables) => void;
  updateDomain: (domain: DomainConfig) => void;
  updateCost: (cost: CostBreakdown) => void;
  markDeployed: () => void;
  resetState: () => void;
}

const DeploymentContext = createContext<DeploymentContextType | undefined>(undefined);

const initialState: DeploymentState = {
  user: null,
  questionnaire: null,
  application: null,
  containers: [],
  resources: null,
  environment: null,
  domain: null,
  cost: null,
  deployed: false,
};

export function DeploymentProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<DeploymentState>(() => {
    // Initialize from localStorage if available
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('unhazzle-deployment-state');
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          // Ensure containers array exists for backward compatibility
          return {
            ...parsed,
            containers: parsed.containers || []
          };
        } catch (e) {
          console.error('Failed to parse saved state:', e);
        }
      }
    }
    return initialState;
  });

  const updateUser = (user: UserInfo) => {
    setState(prev => {
      const newState = { ...prev, user };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateQuestionnaire = (answers: QuestionnaireAnswers) => {
    setState(prev => {
      const newState = { ...prev, questionnaire: answers };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateApplication = (config: ApplicationConfig) => {
    setState(prev => {
      const newState = { ...prev, application: config };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const addContainer = (container: ContainerConfig) => {
    setState(prev => {
      const existingContainers = prev.containers || [];
      const newState = { ...prev, containers: [...existingContainers, container] };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateContainer = (id: string, updates: Partial<ContainerConfig>) => {
    setState(prev => {
      const existingContainers = prev.containers || [];
      const newState = {
        ...prev,
        containers: existingContainers.map(c => 
          c.id === id ? { ...c, ...updates } : c
        )
      };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const removeContainer = (id: string) => {
    setState(prev => {
      const existingContainers = prev.containers || [];
      const newState = {
        ...prev,
        containers: existingContainers.filter(c => c.id !== id)
      };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateResources = (config: ResourceConfig) => {
    setState(prev => {
      const newState = { ...prev, resources: config };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateEnvironment = (env: EnvironmentVariables) => {
    setState(prev => {
      const newState = { ...prev, environment: env };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateDomain = (domain: DomainConfig) => {
    setState(prev => {
      const newState = { ...prev, domain: domain };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateCost = (cost: CostBreakdown) => {
    setState(prev => {
      const newState = { ...prev, cost };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const markDeployed = () => {
    setState(prev => {
      const newState = { ...prev, deployed: true };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const resetState = () => {
    setState(initialState);
    if (typeof window !== 'undefined') {
      localStorage.removeItem('unhazzle-deployment-state');
    }
  };

  return (
    <DeploymentContext.Provider
      value={{
        state,
        updateUser,
        updateQuestionnaire,
        updateApplication,
        addContainer,
        updateContainer,
        removeContainer,
        updateResources,
        updateEnvironment,
        updateDomain,
        updateCost,
        markDeployed,
        resetState,
      }}
    >
      {children}
    </DeploymentContext.Provider>
  );
}

export function useDeployment() {
  const context = useContext(DeploymentContext);
  if (context === undefined) {
    throw new Error('useDeployment must be used within a DeploymentProvider');
  }
  return context;
}
