'use client';

import React, { createContext, useContext, useState, ReactNode } from 'react';

// Types for our deployment configuration
export interface UserInfo {
  name: string;
  githubUsername?: string;
}

export interface QuestionnaireAnswers {
  appType: 'ecommerce' | 'saas' | 'api' | 'content';
  traffic: 'steady' | 'burst' | 'global' | 'regional';
  database: 'postgres' | 'mysql' | 'mongodb' | 'none';
  cache: 'redis' | 'memcached' | 'none';
}

export interface ApplicationConfig {
  imageUrl: string;
  registryUsername?: string;
  registryToken?: string;
  port?: number;
  healthCheck?: string;
}

export interface ResourceConfig {
  replicas: { min: number; max: number };
  cpu: string;
  memory: string;
  database?: {
    engine: string;
    version: string;
    storage: string;
    backups: { enabled: boolean; retention: string; frequency: string };
    replicas: string;
  };
  cache?: {
    engine: string;
    version: string;
    memory: string;
    evictionPolicy: string;
    persistence: string;
  };
}

export interface EnvironmentVariables {
  userSecrets: { key: string; value: string; masked?: boolean }[];
  autoGenerated: { key: string; value: string; readOnly: boolean }[];
}

export interface DomainConfig {
  customDomain?: string;
  defaultSubdomain: string;
  dnsInstructions?: string;
}

export interface CostBreakdown {
  application: number;
  database?: number;
  cache?: number;
  loadBalancer: number;
  bandwidth: number;
  total: number;
}

export interface DeploymentState {
  user: UserInfo | null;
  questionnaire: QuestionnaireAnswers | null;
  application: ApplicationConfig | null;
  resources: ResourceConfig | null;
  environment: EnvironmentVariables | null;
  domain: DomainConfig | null;
  cost: CostBreakdown | null;
  deployed: boolean;
}

interface DeploymentContextType {
  state: DeploymentState;
  updateUser: (user: UserInfo) => void;
  updateQuestionnaire: (answers: QuestionnaireAnswers) => void;
  updateApplication: (config: ApplicationConfig) => void;
  updateResources: (config: ResourceConfig) => void;
  updateEnvironment: (env: EnvironmentVariables) => void;
  updateDomain: (domain: DomainConfig) => void;
  updateCost: (cost: CostBreakdown) => void;
  markDeployed: () => void;
  resetState: () => void;
}

const DeploymentContext = createContext<DeploymentContextType | undefined>(undefined);

const initialState: DeploymentState = {
  user: null,
  questionnaire: null,
  application: null,
  resources: null,
  environment: null,
  domain: null,
  cost: null,
  deployed: false,
};

export function DeploymentProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<DeploymentState>(() => {
    // Initialize from localStorage if available
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('unhazzle-deployment-state');
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          console.error('Failed to parse saved state:', e);
        }
      }
    }
    return initialState;
  });

  const updateUser = (user: UserInfo) => {
    setState(prev => {
      const newState = { ...prev, user };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateQuestionnaire = (answers: QuestionnaireAnswers) => {
    setState(prev => {
      const newState = { ...prev, questionnaire: answers };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateApplication = (config: ApplicationConfig) => {
    setState(prev => {
      const newState = { ...prev, application: config };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateResources = (config: ResourceConfig) => {
    setState(prev => {
      const newState = { ...prev, resources: config };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateEnvironment = (env: EnvironmentVariables) => {
    setState(prev => {
      const newState = { ...prev, environment: env };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateDomain = (domain: DomainConfig) => {
    setState(prev => {
      const newState = { ...prev, domain: domain };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const updateCost = (cost: CostBreakdown) => {
    setState(prev => {
      const newState = { ...prev, cost };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const markDeployed = () => {
    setState(prev => {
      const newState = { ...prev, deployed: true };
      if (typeof window !== 'undefined') {
        localStorage.setItem('unhazzle-deployment-state', JSON.stringify(newState));
      }
      return newState;
    });
  };

  const resetState = () => {
    setState(initialState);
    if (typeof window !== 'undefined') {
      localStorage.removeItem('unhazzle-deployment-state');
    }
  };

  return (
    <DeploymentContext.Provider
      value={{
        state,
        updateUser,
        updateQuestionnaire,
        updateApplication,
        updateResources,
        updateEnvironment,
        updateDomain,
        updateCost,
        markDeployed,
        resetState,
      }}
    >
      {children}
    </DeploymentContext.Provider>
  );
}

export function useDeployment() {
  const context = useContext(DeploymentContext);
  if (context === undefined) {
    throw new Error('useDeployment must be used within a DeploymentProvider');
  }
  return context;
}
